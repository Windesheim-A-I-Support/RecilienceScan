---
title: "Strategic Resilience and Financial Performance Profile for `r params$company`"
subtitle: "An In-depth Analysis by the Supply Chain Finance Lectoraat, Hogeschool Windesheim"
author:
  - name: Ronald de Boer 
    affiliations:
      - name: Supply Chain Finance Lectoraat
      - name: Hogeschool Windesheim
        address: Campus 2, Zwolle
bibliography: references.bib
format: 
  pdf:
    documentclass: scrbook
    classoption: ["oneside", "open=any", "fontsize=11pt"]
    link-citations: false
    number-sections: false
    toc: false
    lof: false
    lot: false
    titlepage: "bg-image"
    titlepage-bg-image: "img/corner-bg.png"
    titlepage-logo: "img/logo.png" 
    titlepage-header: "Resilience Scan | NEXT GEN Logistics Initiative"
    titlepage-footer: |
      Supply Chain Finance Lectoraat, Hogeschool Windesheim\
      https://resiliencescan.org/ | https://www.windesheim.com/research/professorships/supply-chain-finance
    coverpage-include-file:
      - tex/copyright.tex
    titlepage-include-file:
      - tex/dedication.tex
    titlepage-theme:
      vrule-color: "004D40" 
      vrule-width: "10pt"
    coverpage: otter 
    coverpage-bg-image: "img/otter-bar.jpeg"
    coverpage-title: "resiliencescan" 
    coverpage-author: ["Supply Chain Finance Lectoraat, Hogeschool Windesheim", "NEXT GEN Logistics"] 
    coverpage-theme:
      title-color: "white"
      title-fontfamily: "QTDublinIrish.otf" 
      title-fontsize: 70
      author-style: "plain"
      author-sep: "newline"
      author-fontstyle: ["textbf", "textsc"]
      author-fontsize: 24
      author-color: "4CAF50" 
      author-align: "right"
      author-bottom: "1.5in"
      footer-style: "none"
      header-style: "none"
      date-style: "none"
    keep-tex: true
    # Temporarily remove complex header-includes for stability
    # header-includes: |
    #   \usepackage{fancyhdr}
    #   ... (rest of fancyhdr setup) ...
execute:
  echo: false
  warning: false
  message: false
params:
  company: "Placeholder Company"
---



```{r package-installer, include=FALSE}
# Define required R packages
required_packages <- c(
  "readr", "dplyr", "stringr", "tidyr", "ggplot2", 
  "fmsb", "scales", "janitor",
  "rmarkdown", "knitr", "bookdown", "tinytex", "quarto"
)

# Detect and install missing R packages
missing_packages <- required_packages[!sapply(required_packages, requireNamespace, quietly = TRUE)]

if (length(missing_packages) > 0) {
  message("📦 Installing missing R packages: ", paste(missing_packages, collapse = ", "))
  install.packages(missing_packages, repos = "https://cran.rstudio.com/", dependencies = TRUE)
} else {
  message("✅ All required R packages are already installed.")
}

# Check TinyTeX
if (!tinytex::is_tinytex()) {
  message("📦 TinyTeX not detected — installing TinyTeX...")
  tinytex::install_tinytex()
} else {
  message("✅ TinyTeX already installed.")
}

# Check Quarto CLI
quarto_path <- Sys.which("quarto")

if (quarto_path == "") {
  warning("❌ Quarto CLI is not installed! Please install it from https://quarto.org/download/ before continuing.")
} else {
  message("✅ Quarto CLI detected at: ", quarto_path)
  
  # Install Quarto extension WITHOUT prompt, WITHOUT opening docs
  message("📦 Installing Quarto extension: nmfs-opensci/quarto_titlepages (no prompt, no docs)...")
  system2(quarto_path, args = c("install", "extension", "nmfs-opensci/quarto_titlepages", "--no-prompt", "--no-open"))
}
```

```{r helpers, include=FALSE}
# This chunk defines reusable helper functions to keep the main setup chunk clean.
# It makes the report logic easier to understand and debug.

#' Convert a value to numeric, robustly handling common non-numeric entries.
#'
#' @param x The input value (can be a character or factor).
#' @return A numeric value or NA.
#' 
#' 
# Add this function to your 'helpers' R chunk
#' Safely format a score for printing, returning "N/A" if the score is missing.
#'
#' @param score The numeric score value.
#' @return A formatted character string (e.g., "3.45" or "N/A").
safe_print_score <- function(score) {
  # This logic is identical to the ifelse() statements used in your original, working code.
  if (is.na(score) || is.null(score) || !is.numeric(score)) {
    return("N/A")
  }
  return(sprintf("%.2f", score))
}
convert_to_numeric_simple <- function(x) {
  x_char <- as.character(x)
  # Unify all common missing/invalid formats to NA
  x_char <- ifelse(tolower(trimws(x_char)) %in% c("?", "", " ", "n/a", "na", "n.a.", "nan"), NA_character_, x_char)
  # Convert comma decimal separator to period and suppress warnings for NAs
  suppressWarnings(as.numeric(str_replace(x_char, ",", ".")))
}
```


```{r setup, include=FALSE}
library(readr)
library(dplyr)
library(stringr)
library(tidyr)
library(ggplot2)
library(fmsb)
library(scales) 

convert_to_numeric_simple <- function(x) {
  x_char <- as.character(x)
  x_char <- ifelse(tolower(trimws(x_char)) %in% c("?", "", " ", "n/a", "na", "n.a.", "nan"), NA_character_, x_char)
  suppressWarnings(as.numeric(str_replace(x_char, ",", ".")))
}

df_full <- read_csv("data/cleaned_master.csv", col_types = cols(.default = "c"))
colnames(df_full) <- tolower(trimws(colnames(df_full)))

df_company_raw <- df_full %>% 
  filter(tolower(company_name) == tolower(params$company))

# Define only the columns absolutely needed for conversion for the main scores
# This reduces the chance of an odd column name causing issues in 'across'
score_columns_to_convert <- c(
  "up__r", "up__c", "up__f", "up__v", "up__a",
  "in__r", "in__c", "in__f", "in__v", "in__a",
  "do__r", "do__c", "do__f", "do__v", "do__a",
  "overall_scres"
)
# Add other informational columns that might be used directly if they don't need conversion for scores
info_cols_to_keep <- c("company_name", "sector", "size_number_of_employees") # Add others if used directly

# Ensure only existing columns are processed
actual_score_columns_to_convert <- intersect(score_columns_to_convert, names(df_company_raw))
actual_info_cols_to_keep <- intersect(info_cols_to_keep, names(df_company_raw))

df_company_numeric <- df_company_raw # Start with the raw filtered data

if (length(actual_score_columns_to_convert) > 0) {
    df_company_numeric <- df_company_numeric %>%
      mutate(across(all_of(actual_score_columns_to_convert), convert_to_numeric_simple))
}


up_cols <- c("up__r", "up__c", "up__f", "up__v", "up__a")
in_cols <- c("in__r", "in__c", "in__f", "in__v", "in__a")
do_cols <- c("do__r", "do__c", "do__f", "do__v", "do__a")
max_score <- 5 
min_score <- 0 
dimension_labels <- c("Resilience", "Connectivity", "Financial", "Visibility", "Agility")

data_up_radar <- NULL
data_in_radar <- NULL
data_do_radar <- NULL
company_sector <- "Not Specified" 
company_size <- "Not Specified"   

if(nrow(df_company_numeric) >= 1) {
  if(nrow(df_company_numeric) > 1) {
    warning(paste("Multiple rows found for company:", params$company, ". Using the first row only."))
    df_company_numeric <- df_company_numeric[1, , drop = FALSE] 
  }
  
  # Safely get sector and size
  company_sector <- if("sector" %in% names(df_company_numeric) && !is.na(df_company_numeric$sector) && df_company_numeric$sector != "") df_company_numeric$sector else "Not Specified"
  company_size <- if("size_number_of_employees" %in% names(df_company_numeric) && !is.na(df_company_numeric$size_number_of_employees) && df_company_numeric$size_number_of_employees != "") df_company_numeric$size_number_of_employees else "Not Specified"

  # Calculate pillar scores directly
  if(all(up_cols %in% names(df_company_numeric))) {
    df_company_numeric$up_pillar_score <- rowMeans(select(df_company_numeric, all_of(up_cols)), na.rm = TRUE)
    # Prepare radar data
    radar_data <- df_company_numeric %>% slice(1) %>% select(all_of(up_cols))
    if(ncol(radar_data) == 5 && !all(is.na(as.numeric(radar_data[1,])))) {
        data_up_radar <- data.frame(rbind(rep(max_score, 5), rep(min_score, 5), as.numeric(radar_data[1,])))
        colnames(data_up_radar) <- dimension_labels
    } else { warning(paste("Upstream radar data for", params$company, "could not be prepared."))}
  } else { df_company_numeric$up_pillar_score <- NA }

  if(all(in_cols %in% names(df_company_numeric))) {
    df_company_numeric$in_pillar_score <- rowMeans(select(df_company_numeric, all_of(in_cols)), na.rm = TRUE)
    radar_data <- df_company_numeric %>% slice(1) %>% select(all_of(in_cols))
    if(ncol(radar_data) == 5 && !all(is.na(as.numeric(radar_data[1,])))) {
        data_in_radar <- data.frame(rbind(rep(max_score, 5), rep(min_score, 5), as.numeric(radar_data[1,])))
        colnames(data_in_radar) <- dimension_labels
    } else { warning(paste("Internal radar data for", params$company, "could not be prepared."))}
  } else { df_company_numeric$in_pillar_score <- NA }

  if(all(do_cols %in% names(df_company_numeric))) {
    df_company_numeric$do_pillar_score <- rowMeans(select(df_company_numeric, all_of(do_cols)), na.rm = TRUE)
    radar_data <- df_company_numeric %>% slice(1) %>% select(all_of(do_cols))
    if(ncol(radar_data) == 5 && !all(is.na(as.numeric(radar_data[1,])))) {
        data_do_radar <- data.frame(rbind(rep(max_score, 5), rep(min_score, 5), as.numeric(radar_data[1,])))
        colnames(data_do_radar) <- dimension_labels
    } else { warning(paste("Downstream radar data for", params$company, "could not be prepared."))}
  } else { df_company_numeric$do_pillar_score <- NA }

} else if (nrow(df_company_numeric) == 0) {
  stop(paste("No data found for company:", params$company, ". Halting report generation."))
}
```


```{r pillar-scores-chart, fig.cap=paste("Average Resilience Pillar Scores for", params$company), fig.asp=0.6, out.width="100%"}
if (exists("df_company_numeric") && nrow(df_company_numeric) > 0 &&
    all(c("up_pillar_score", "in_pillar_score", "do_pillar_score") %in% names(df_company_numeric))) {
      
  pillar_data_scores <- c(df_company_numeric$up_pillar_score, 
                          df_company_numeric$in_pillar_score, 
                          df_company_numeric$do_pillar_score)
  
  if(any(!is.na(pillar_data_scores))) {
    pillar_data_df <- data.frame(
      Pillar = c("Upstream", "Internal", "Downstream"),
      Score = pillar_data_scores
    )
    pillar_data_df$Pillar <- factor(pillar_data_df$Pillar, levels = c("Upstream", "Internal", "Downstream"))

    ggplot(pillar_data_df, aes(x = Pillar, y = Score, fill = Pillar)) +
      geom_bar(stat = "identity", width = 0.7, show.legend = FALSE, alpha=0.9) +
      geom_text(aes(label = ifelse(is.na(Score), "N/A", sprintf("%.2f", Score))), 
                vjust = -0.7, size = 4, na.rm = TRUE, fontface="bold") +
      scale_fill_manual(values = c("Upstream" = "#0277BD", "Internal" = "#FF8F00", "Downstream" = "#2E7D32")) +
      labs(title = paste("Resilience Pillar Scores for", params$company),
           y = "Average Score (0-5)", x = "") +
      theme_minimal(base_size = 11) +
      theme(plot.title = element_text(hjust = 0.5, size=14, face="bold"),
            axis.title.y = element_text(size=10, face="bold"),
            axis.text.x = element_text(size=10, face="bold"),
            axis.text.y = element_text(size=9),
            panel.grid.major.x = element_blank(),
            panel.grid.minor.y = element_blank()) +
      ylim(0, max_score + 0.5) 
  } else {
    cat(paste0("Pillar scores for ", params$company, " are all NA or data is unavailable for the pillar scores chart."))
  }
} else {
  cat(paste0("Pillar score data frame (`df_company_numeric`) not available for ", params$company, " or key columns missing for plotting."))
}
```

```{r upstream-radar-chart, fig.cap=paste("Upstream Resilience Dimensions for", params$company), fig.asp=0.8, out.width="80%", fig.align="center"}
if (exists("data_up_radar") && 
    !is.null(data_up_radar) && 
    is.data.frame(data_up_radar) && 
    nrow(data_up_radar) == 3 && 
    ncol(data_up_radar) == 5 && 
    all(sapply(data_up_radar, is.numeric)) &&
    !all(is.na(data_up_radar[3, , drop=FALSE])) ) {
  radarchart(data_up_radar, axistype = 1, 
             pcol = "#0277BD", pfcol = scales::alpha("#0277BD", 0.5), plwd = 2, plty=1,
             cglcol = "grey", cglty = 1, axislabcol = "grey40", 
             caxislabels = sprintf("%.1f", seq(min_score, max_score, length.out = 6)), 
             cglwd = 0.8, vlcex = 0.9, centerzero = TRUE,
             title = "") 
} else {
  cat(paste0("Data for upstream radar chart for ", params$company, " is not available, not fully numeric, incorrectly formatted, or all values are NA."))
}
```


```{r internal-radar-chart, fig.cap=paste("Internal Operational Resilience Dimensions for", params$company), fig.asp=0.8, out.width="80%", fig.align="center"}
if (exists("data_in_radar") && 
    !is.null(data_in_radar) && 
    is.data.frame(data_in_radar) && 
    nrow(data_in_radar) == 3 && 
    ncol(data_in_radar) == 5 && 
    all(sapply(data_in_radar, is.numeric)) &&
    !all(is.na(data_in_radar[3, , drop=FALSE])) ) {
  radarchart(data_in_radar, axistype = 1,
             pcol = "#FF8F00", pfcol = scales::alpha("#FF8F00", 0.5), plwd = 2, plty=1,
             cglcol = "grey", cglty = 1, axislabcol = "grey40",
             caxislabels = sprintf("%.1f", seq(min_score, max_score, length.out = 6)),
             cglwd = 0.8, vlcex = 0.9, centerzero = TRUE,
             title = "")
} else {
  cat(paste0("Data for internal radar chart for ", params$company, " is not available, not fully numeric, incorrectly formatted, or all values are NA."))
}
```


```{r downstream-radar-chart, fig.cap=paste("Downstream Resilience Dimensions for", params$company), fig.asp=0.8, out.width="80%", fig.align="center"}
if (exists("data_do_radar") && 
    !is.null(data_do_radar) && 
    is.data.frame(data_do_radar) && 
    nrow(data_do_radar) == 3 && 
    ncol(data_do_radar) == 5 && 
    all(sapply(data_do_radar, is.numeric)) &&
    !all(is.na(data_do_radar[3, , drop=FALSE])) ) {
  radarchart(data_do_radar, axistype = 1,
             pcol = "#2E7D32", pfcol = scales::alpha("#2E7D32", 0.5), plwd = 2, plty=1,
             cglcol = "grey", cglty = 1, axislabcol = "grey40",
             caxislabels = sprintf("%.1f", seq(min_score, max_score, length.out = 6)), 
             cglwd = 0.8, vlcex = 0.9, centerzero = TRUE,
             title = "")
} else {
  cat(paste0("Data for downstream radar chart for ", params$company, " is not available, not fully numeric, incorrectly formatted, or all values are NA."))
}
```
