---
title: "Strategic Resilience and Financial Performance Profile for `r params$company`"
subtitle: "An In-depth Analysis by the Supply Chain Finance Lectoraat, Hogeschool Windesheim"
author:
  - name: Ronald de Boer 
    affiliations:
      - name: Supply Chain Finance Lectoraat
      - name: Hogeschool Windesheim
        address: Campus 2, Zwolle
bibliography: references.bib
format: 
  pdf:
    documentclass: scrbook
    classoption: ["oneside", "open=any", "fontsize=11pt"]
    link-citations: false
    number-sections: false
    toc: false
    lof: false
    lot: false
    titlepage: "bg-image"
    titlepage-bg-image: "img/corner-bg.png"
    titlepage-logo: "img/logo.png" 
    titlepage-header: "Resilience Scan | NEXT GEN Logistics Initiative"
    titlepage-footer: |
      Supply Chain Finance Lectoraat, Hogeschool Windesheim\
      https://resiliencescan.org/ | https://www.windesheim.com/research/professorships/supply-chain-finance
    coverpage-include-file:
      - tex/copyright.tex
    titlepage-include-file:
      - tex/dedication.tex
    titlepage-theme:
      vrule-color: "004D40" 
      vrule-width: "10pt"
    coverpage: otter 
    coverpage-bg-image: "img/otter-bar.jpeg"
    coverpage-title: "resiliencescan" 
    coverpage-author: ["Supply Chain Finance Lectoraat, Hogeschool Windesheim", "NEXT GEN Logistics"] 
    coverpage-theme:
      title-color: "white"
      title-fontfamily: "QTDublinIrish.otf" 
      title-fontsize: 70
      author-style: "plain"
      author-sep: "newline"
      author-fontstyle: ["textbf", "textsc"]
      author-fontsize: 24
      author-color: "4CAF50" 
      author-align: "right"
      author-bottom: "1.5in"
      footer-style: "none"
      header-style: "none"
      date-style: "none"
    keep-tex: true
    # Temporarily remove complex header-includes for stability
    # header-includes: |
    #   \usepackage{fancyhdr}
    #   ... (rest of fancyhdr setup) ...
execute:
  echo: false
  warning: false
  message: false
params:
  company: "Placeholder Company"
---



```{r package-installer, include=FALSE}
# Define required R packages
required_packages <- c(
  "readr", "dplyr", "stringr", "tidyr", "ggplot2", 
  "fmsb", "scales", "janitor",
  "rmarkdown", "knitr", "bookdown", "tinytex", "quarto"
)

# Detect and install missing R packages
missing_packages <- required_packages[!sapply(required_packages, requireNamespace, quietly = TRUE)]

if (length(missing_packages) > 0) {
  message("📦 Installing missing R packages: ", paste(missing_packages, collapse = ", "))
  install.packages(missing_packages, repos = "https://cran.rstudio.com/", dependencies = TRUE)
} else {
  message("✅ All required R packages are already installed.")
}

# Check TinyTeX
if (!tinytex::is_tinytex()) {
  message("📦 TinyTeX not detected — installing TinyTeX...")
  tinytex::install_tinytex()
} else {
  message("✅ TinyTeX already installed.")
}

# Check Quarto CLI
quarto_path <- Sys.which("quarto")

if (quarto_path == "") {
  warning("❌ Quarto CLI is not installed! Please install it from https://quarto.org/download/ before continuing.")
} else {
  message("✅ Quarto CLI detected at: ", quarto_path)
  
  # Install Quarto extension WITHOUT prompt, WITHOUT opening docs
  message("📦 Installing Quarto extension: nmfs-opensci/quarto_titlepages (no prompt, no docs)...")
  system2(quarto_path, args = c("install", "extension", "nmfs-opensci/quarto_titlepages", "--no-prompt"))
}
```

```{r helpers, include=FALSE}
# This chunk defines reusable helper functions to keep the main setup chunk clean.
# It makes the report logic easier to understand and debug.

#' Convert a value to numeric, robustly handling common non-numeric entries.
#'
#' @param x The input value (can be a character or factor).
#' @return A numeric value or NA.
#' 
#' 
# Add this function to your 'helpers' R chunk
#' Safely format a score for printing, returning "N/A" if the score is missing.
#'
#' @param score The numeric score value.
#' @return A formatted character string (e.g., "3.45" or "N/A").
safe_print_score <- function(score) {
  # This logic is identical to the ifelse() statements used in your original, working code.
  if (is.na(score) || is.null(score) || !is.numeric(score)) {
    return("N/A")
  }
  return(sprintf("%.2f", score))
}
convert_to_numeric_simple <- function(x) {
  x_char <- as.character(x)
  # Unify all common missing/invalid formats to NA
  x_char <- ifelse(tolower(trimws(x_char)) %in% c("?", "", " ", "n/a", "na", "n.a.", "nan"), NA_character_, x_char)
  # Convert comma decimal separator to period and suppress warnings for NAs
  suppressWarnings(as.numeric(str_replace(x_char, ",", ".")))
}
```


```{r setup, include=FALSE}
library(readr)
library(dplyr)
library(stringr)
library(tidyr)
library(ggplot2)
library(fmsb)
library(scales) 

convert_to_numeric_simple <- function(x) {
  x_char <- as.character(x)
  x_char <- ifelse(tolower(trimws(x_char)) %in% c("?", "", " ", "n/a", "na", "n.a.", "nan"), NA_character_, x_char)
  suppressWarnings(as.numeric(str_replace(x_char, ",", ".")))
}

df_full <- read_csv("data/cleaned_master.csv", col_types = cols(.default = "c"))
colnames(df_full) <- tolower(trimws(colnames(df_full)))

df_company_raw <- df_full %>% 
  filter(tolower(company_name) == tolower(params$company))

# Define only the columns absolutely needed for conversion for the main scores
# This reduces the chance of an odd column name causing issues in 'across'
score_columns_to_convert <- c(
  "up__r", "up__c", "up__f", "up__v", "up__a",
  "in__r", "in__c", "in__f", "in__v", "in__a",
  "do__r", "do__c", "do__f", "do__v", "do__a",
  "overall_scres"
)
# Add other informational columns that might be used directly if they don't need conversion for scores
info_cols_to_keep <- c("company_name", "sector", "size_number_of_employees") # Add others if used directly

# Ensure only existing columns are processed
actual_score_columns_to_convert <- intersect(score_columns_to_convert, names(df_company_raw))
actual_info_cols_to_keep <- intersect(info_cols_to_keep, names(df_company_raw))

df_company_numeric <- df_company_raw # Start with the raw filtered data

if (length(actual_score_columns_to_convert) > 0) {
    df_company_numeric <- df_company_numeric %>%
      mutate(across(all_of(actual_score_columns_to_convert), convert_to_numeric_simple))
}


up_cols <- c("up__r", "up__c", "up__f", "up__v", "up__a")
in_cols <- c("in__r", "in__c", "in__f", "in__v", "in__a")
do_cols <- c("do__r", "do__c", "do__f", "do__v", "do__a")
max_score <- 5 
min_score <- 0 
dimension_labels <- c("Redundancy", "Collaboration", "Flexibility", "Transparency", "Agility")

data_up_radar <- NULL
data_in_radar <- NULL
data_do_radar <- NULL
company_sector <- "Not Specified" 
company_size <- "Not Specified"   

if(nrow(df_company_numeric) >= 1) {
  if(nrow(df_company_numeric) > 1) {
    warning(paste("Multiple rows found for company:", params$company, ". Using the first row only."))
    df_company_numeric <- df_company_numeric[1, , drop = FALSE] 
  }
  
  # Safely get sector and size
  company_sector <- if("sector" %in% names(df_company_numeric) && !is.na(df_company_numeric$sector) && df_company_numeric$sector != "") df_company_numeric$sector else "Not Specified"
  company_size <- if("size_number_of_employees" %in% names(df_company_numeric) && !is.na(df_company_numeric$size_number_of_employees) && df_company_numeric$size_number_of_employees != "") df_company_numeric$size_number_of_employees else "Not Specified"

  # Calculate pillar scores directly
  if(all(up_cols %in% names(df_company_numeric))) {
    df_company_numeric$up_pillar_score <- rowMeans(select(df_company_numeric, all_of(up_cols)), na.rm = TRUE)
    # Prepare radar data
    radar_data <- df_company_numeric %>% slice(1) %>% select(all_of(up_cols))
    if(ncol(radar_data) == 5 && !all(is.na(as.numeric(radar_data[1,])))) {
        data_up_radar <- data.frame(rbind(rep(max_score, 5), rep(min_score, 5), as.numeric(radar_data[1,])))
        colnames(data_up_radar) <- dimension_labels
    } else { warning(paste("Upstream radar data for", params$company, "could not be prepared."))}
  } else { df_company_numeric$up_pillar_score <- NA }

  if(all(in_cols %in% names(df_company_numeric))) {
    df_company_numeric$in_pillar_score <- rowMeans(select(df_company_numeric, all_of(in_cols)), na.rm = TRUE)
    radar_data <- df_company_numeric %>% slice(1) %>% select(all_of(in_cols))
    if(ncol(radar_data) == 5 && !all(is.na(as.numeric(radar_data[1,])))) {
        data_in_radar <- data.frame(rbind(rep(max_score, 5), rep(min_score, 5), as.numeric(radar_data[1,])))
        colnames(data_in_radar) <- dimension_labels
    } else { warning(paste("Internal radar data for", params$company, "could not be prepared."))}
  } else { df_company_numeric$in_pillar_score <- NA }

  if(all(do_cols %in% names(df_company_numeric))) {
    df_company_numeric$do_pillar_score <- rowMeans(select(df_company_numeric, all_of(do_cols)), na.rm = TRUE)
    radar_data <- df_company_numeric %>% slice(1) %>% select(all_of(do_cols))
    if(ncol(radar_data) == 5 && !all(is.na(as.numeric(radar_data[1,])))) {
        data_do_radar <- data.frame(rbind(rep(max_score, 5), rep(min_score, 5), as.numeric(radar_data[1,])))
        colnames(data_do_radar) <- dimension_labels
    } else { warning(paste("Downstream radar data for", params$company, "could not be prepared."))}
  } else { df_company_numeric$do_pillar_score <- NA }

} else if (nrow(df_company_numeric) == 0) {
  stop(paste("No data found for company:", params$company, ". Halting report generation."))
}
```

```{r}
# --- Prepare "overall" radar (mean of each dimension across Upstream/Internal/Downstream) ---
has_up <- exists("data_up_radar") && is.data.frame(data_up_radar) && nrow(data_up_radar) == 3 && ncol(data_up_radar) == 5 && all(sapply(data_up_radar, is.numeric)) && !all(is.na(data_up_radar[3, , drop=FALSE]))
has_in <- exists("data_in_radar") && is.data.frame(data_in_radar) && nrow(data_in_radar) == 3 && ncol(data_in_radar) == 5 && all(sapply(data_in_radar, is.numeric)) && !all(is.na(data_in_radar[3, , drop=FALSE]))
has_do <- exists("data_do_radar") && is.data.frame(data_do_radar) && nrow(data_do_radar) == 3 && ncol(data_do_radar) == 5 && all(sapply(data_do_radar, is.numeric)) && !all(is.na(data_do_radar[3, , drop=FALSE]))

if (has_up || has_in || has_do) {
  # Build an overall row by averaging available segment rows (3rd row of each dataset)
  available_rows <- list()
  if (has_up) available_rows <- append(available_rows, list(as.numeric(data_up_radar[3,])))
  if (has_in) available_rows <- append(available_rows, list(as.numeric(data_in_radar[3,])))
  if (has_do) available_rows <- append(available_rows, list(as.numeric(data_do_radar[3,])))

  overall_vec <- Reduce("+", available_rows) / length(available_rows)
  data_overall_radar <- data.frame(rbind(
    rep(max_score, 5),
    rep(min_score, 5),
    overall_vec
  ))
  colnames(data_overall_radar) <- dimension_labels
} else {
  data_overall_radar <- NULL
}

# --- Overlay dataset: Up vs In vs Down on one radar (optional fifth chart) ---
overlay_data <- NULL
if (has_up || has_in || has_do) {
  # Start with max/min
  overlay_data <- rbind(rep(max_score, 5), rep(min_score, 5))
  # Append available segments in consistent order Redundancy..Agility
  if (has_up) overlay_data <- rbind(overlay_data, as.numeric(data_up_radar[3,]))
  if (has_in) overlay_data <- rbind(overlay_data, as.numeric(data_in_radar[3,]))
  if (has_do) overlay_data <- rbind(overlay_data, as.numeric(data_do_radar[3,]))
  overlay_data <- as.data.frame(overlay_data)
  colnames(overlay_data) <- dimension_labels
}

# --- Draw 5 radars on one page (2x3 grid) ---
op <- par(no.readonly = TRUE)
on.exit(par(op), add = TRUE)

# Make panels physically bigger: full text width + taller device + tiny margins
par(mfrow = c(2, 3), mar = c(0.2, 0.35, 1.0, 0.2), oma = c(0, 0, 0, 0), cex = 1.0)

# 1) Overall
if (!is.null(data_overall_radar)) {
  fmsb::radarchart(
    data_overall_radar, axistype = 1,
    pcol = "#6A1B9A", pfcol = scales::alpha("#6A1B9A", 0.4), plwd = 2, plty = 1,
    cglcol = "grey80", cglty = 1, axislabcol = "grey40",
    caxislabels = sprintf("%.1f", seq(min_score, max_score, length.out = 6)),
    cglwd = 0.8, vlcex = 0.95, centerzero = TRUE, title = "Overall"
  )
} else {
  plot.new(); title("Overall\n(no data)")
}

# 2) Upstream
if (has_up) {
  fmsb::radarchart(
    data_up_radar, axistype = 1,
    pcol = "#0277BD", pfcol = scales::alpha("#0277BD", 0.45), plwd = 2, plty = 1,
    cglcol = "grey80", cglty = 1, axislabcol = "grey40",
    caxislabels = sprintf("%.1f", seq(min_score, max_score, length.out = 6)),
    cglwd = 0.8, vlcex = 0.95, centerzero = TRUE, title = "Upstream"
  )
} else {
  plot.new(); title("Upstream\n(no data)")
}

# 3) Internal
if (has_in) {
  fmsb::radarchart(
    data_in_radar, axistype = 1,
    pcol = "#FF8F00", pfcol = scales::alpha("#FF8F00", 0.45), plwd = 2, plty = 1,
    cglcol = "grey80", cglty = 1, axislabcol = "grey40",
    caxislabels = sprintf("%.1f", seq(min_score, max_score, length.out = 6)),
    cglwd = 0.8, vlcex = 0.95, centerzero = TRUE, title = "Internal"
  )
} else {
  plot.new(); title("Internal\n(no data)")
}

# 4) Downstream
if (has_do) {
  fmsb::radarchart(
    data_do_radar, axistype = 1,
    pcol = "#2E7D32", pfcol = scales::alpha("#2E7D32", 0.45), plwd = 2, plty = 1,
    cglcol = "grey80", cglty = 1, axislabcol = "grey40",
    caxislabels = sprintf("%.1f", seq(min_score, max_score, length.out = 6)),
    cglwd = 0.8, vlcex = 0.95, centerzero = TRUE, title = "Downstream"
  )
} else {
  plot.new(); title("Downstream\n(no data)")
}

# 5) Overlay (Up vs In vs Down)
if (!is.null(overlay_data)) {
  n_series <- nrow(overlay_data) - 2
  cols <- c("#0277BD", "#FF8F00", "#2E7D32")[seq_len(n_series)]
  fcols <- sapply(cols, function(z) scales::alpha(z, 0.25))
  fmsb::radarchart(
    overlay_data, axistype = 1,
    pcol = cols, pfcol = fcols, plwd = 2, plty = 1,
    cglcol = "grey80", cglty = 1, axislabcol = "grey40",
    caxislabels = sprintf("%.1f", seq(min_score, max_score, length.out = 6)),
    cglwd = 0.8, vlcex = 0.95, centerzero = TRUE, title = "Overlay: Up / In / Down"
  )
  legend("bottomleft",
         legend = c(if (has_up) "Upstream" else NULL,
                    if (has_in) "Internal" else NULL,
                    if (has_do) "Downstream" else NULL),
         bty = "n", cex = 0.9, text.col = "grey20")
} else {
  plot.new(); title("Overlay\n(no data)")
}

# 6) leave the last cell blank for clean spacing
plot.new(); title("")


```
